# Fernando Carrillo A01194204# Tarea 1: Optimizacion ciega# Encontrar el menor valor de la ecuacion y = x3 − 2x2 + 1 # en el intervalo 0 ≤ x ≤ 5import numpy as np### FUNCIONES AUXILIARES #### Funcion a evaluar  - y = x^3 - 2x^2 + 1def Evalua(x):    return pow(x, 3) - (2 * pow(x, 2)) + 1# Genera vecino de xdef Mutacion(x):    mutacion = x * np.random.uniform(0.6, 1.2)    # Limita el dominio a que sea la mutacion no sea mayor a 5    while (mutacion > 5):        mutacion *= np.random.uniform(0.6, 1.0)       return mutacion# Elige el hijo que resulta en el menor valor de evaluaciondef Mejor(hijos):    mejor_hijo = hijos[0]    mejor_valor = Evalua(hijos[0])        for hijo in hijos:        valor_act = Evalua(hijo)        if (valor_act < mejor_valor):            mejor_hijo = hijo            mejor_valor = valor_act        return mejor_hijo# Elige los M mejores hijos que tienen los menores valores al ser evaluadosdef Mejores(hijos, M):    # Guarda los hijos junto con su evaluacion y los ordena ascendentemente por su evaluacion    hijos_valores = []    for hijo in hijos:        hijos_valores.append((hijo, Evalua(hijo)))    hijos_valores = sorted(hijos_valores, key=lambda item : item[1])        mejores = []    for i in range(M):        mejores.append(hijos_valores[i][0])    return mejores        ### FUNCIONES AUXILIARES ###    ### SOLUCION ###    NUM_ITERACIONES = 50NUM_PADRES = 30NUM_HIJOS = 50# Un padre, varios hijosdef UnPadreVariosHijos():    padre = np.random.uniform(0, 5)    for _ in range(NUM_ITERACIONES):        hijos = []        for hijo in range(NUM_HIJOS):            hijos.append(Mutacion(padre))        padre = Mejor(hijos)    return padreresultado1 = np.round(UnPadreVariosHijos(), 4)print("Un padre, varios hijos - ",       "\n\tValor x: ", resultado1,      "\tEvaluacion de x: ", np.round(Evalua(resultado1), 4))# Varios padres, varios hijos sin traslape generacionaldef VariosPadresVariosHijos1():    padres = [np.random.uniform(0, 5) for padre in range(NUM_PADRES)]    for _ in range(NUM_ITERACIONES):        hijos = []        for hijo in range(NUM_HIJOS):            padre = padres[np.random.randint(0, NUM_PADRES-1)]            hijos.append(Mutacion(padre))        padres = Mejores(hijos, NUM_PADRES)    return Mejor(padres)resultado2 = np.round(VariosPadresVariosHijos1(), 4)print("Varios padres, varios hijos sin traslape - ",       "\n\tValor x: ", resultado2,      "\tEvaluacion de x: ", np.round(Evalua(resultado2), 4))# Varios padres, varios hijos con traslape generacionaldef VariosPadresVariosHijos2():    padres = [np.random.uniform(0, 5) for padre in range(NUM_PADRES)]    for it in range(NUM_ITERACIONES):        hijos = []        for hijo in range(NUM_HIJOS):            padre = padres[np.random.randint(0, NUM_PADRES-1)]            hijos.append(Mutacion(padre))        padres = Mejores(padres+hijos, NUM_PADRES)    return Mejor(padres)resultado3 = np.round(VariosPadresVariosHijos2(), 4)print("Varios padres, varios hijos con traslape - ",       "\n\tValor x: ", resultado3,      "\tEvaluacion de x: ", np.round(Evalua(resultado3), 4))### SOLUCION ###